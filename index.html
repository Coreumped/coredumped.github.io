<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>随便写写</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="小白一个">
<meta property="og:type" content="website">
<meta property="og:title" content="随便写写">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="随便写写">
<meta property="og:description" content="小白一个">
<meta property="og:locale">
<meta property="article:author" content="Dong Hong Yu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="随便写写" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">随便写写</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/17/hello-world/" class="article-date">
  <time datetime="2020-08-17T09:48:24.028Z" itemprop="datePublished">2020-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/17/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/17/hello-world/" data-id="ckdyc8e3z000srluuhew513qe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Innodb系统表-结构解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2020-08-17T07:25:56.000Z" itemprop="datePublished">2020-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/">Innodb系统表-结构解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Innodb系统表-结构解析"><a href="#Innodb系统表-结构解析" class="headerlink" title="Innodb系统表-结构解析"></a>Innodb系统表-结构解析</h1><blockquote>
<p> MySQL中在information_schema下， 有几张’INNODB_SYS%’命名的系统表，其中记录了当前实例下Inoodb存储的表和索引等信息，也称之为数据字典，这些内容存储在ibdata1系统表空间文件中。在某些情况下，没有了.frm文件，也可以读取ibdata1文件获取对应的表结构。本文即介绍一下系统表空间结构及如何读取ibdata文件。</p>
</blockquote>
<p>[TOC]</p>
<h2 id="基本文件结构介绍"><a href="#基本文件结构介绍" class="headerlink" title="基本文件结构介绍"></a>基本文件结构介绍</h2><h3 id="数据页组成及类型"><a href="#数据页组成及类型" class="headerlink" title="数据页组成及类型"></a>数据页组成及类型</h3><p>数据文件和系统文件都是由多个数据页组成，每个数据页16K(默认)，每个数据页都有不同的作用，有以下几种类型(storage/innobase/include/fil0fil.h):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** File page types (values of FIL_PAGE_TYPE) @&#123; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_INDEX 17855 <span class="comment">/*!&lt; B-tree node */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_RTREE 17854 <span class="comment">/*!&lt; B-tree node */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_UNDO_LOG 2 <span class="comment">/*!&lt; Undo log page */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_INODE 3 <span class="comment">/*!&lt; Index node */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_IBUF_FREE_LIST 4 <span class="comment">/*!&lt; Insert buffer free list */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File page types introduced in MySQL/InnoDB 5.1.7 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_TYPE_ALLOCATED 0 <span class="comment">/*!&lt; Freshly allocated page */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_IBUF_BITMAP 5 <span class="comment">/*!&lt; Insert buffer bitmap */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_TYPE_SYS 6 <span class="comment">/*!&lt; System page */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_TYPE_TRX_SYS 7 <span class="comment">/*!&lt; Transaction system data */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_TYPE_FSP_HDR 8 <span class="comment">/*!&lt; File space header */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIL_PAGE_TYPE_XDES 9 <span class="comment">/*!&lt; Extent descriptor page */</span></span></span><br><span class="line"></span><br><span class="line">...省略一些不太关注的类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个数据页头部有38自己的 FIL Header ， 结构内容:</p>
<table>
<thead>
<tr>
<th>大小(字节)</th>
<th>字段</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>Checksum</td>
</tr>
<tr>
<td>4</td>
<td>Previous Page</td>
</tr>
<tr>
<td>4</td>
<td>Next Page</td>
</tr>
<tr>
<td>8</td>
<td>LSN for last page modification</td>
</tr>
<tr>
<td>2</td>
<td>Page Type</td>
</tr>
<tr>
<td>8</td>
<td>Flush LSN</td>
</tr>
<tr>
<td>4</td>
<td>Space ID</td>
</tr>
</tbody></table>
<p>解析FIL Header可以得到一些有用内容:</p>
<ul>
<li><p>offset //相对文件的偏移量</p>
</li>
<li><p>previous/next page //当前页面前后节点的偏移量， 构成链表</p>
</li>
<li><p>page type //page的类型，对应上面所述</p>
</li>
<li><p>space id //表空间ID</p>
</li>
</ul>
<h3 id="ibdata1文件结构"><a href="#ibdata1文件结构" class="headerlink" title="ibdata1文件结构"></a>ibdata1文件结构</h3><p>ibdata1文件是系统表空间，space id为0 ， 结构如下:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/ibdata1_file_overview.jpg" class="">

<p>从上图中看到，ibdata1文件中的第7个页面，为FIL_PAGE_TYPE_SYS类型数据页，存放 Data Dictionary Header ，这个页面中存储内容对应的偏移量如下(storage/innobase/include/dict0boot.h):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The offset of the dictionary header on the page */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR FSEG_PAGE_DATA <span class="comment">//38字节文件头部信息</span></span></span><br><span class="line"></span><br><span class="line">/-------------------------------------------------------------/</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Dictionary header offsets */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_ROW_ID 0 <span class="comment">/* The latest assigned row id */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_TABLE_ID 8 <span class="comment">/* The latest assigned table id */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_INDEX_ID 16 <span class="comment">/* The latest assigned index id */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_MAX_SPACE_ID 24 <span class="comment">/* The latest assigned space id,or 0*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_MIX_ID_LOW 28 <span class="comment">/* Obsolete,always DICT_HDR_FIRST_ID*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_TABLES 32 <span class="comment">/* Root of SYS_TABLES clust index */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_TABLE_IDS 36 <span class="comment">/* Root of SYS_TABLE_IDS sec index */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_COLUMNS 40 <span class="comment">/* Root of SYS_COLUMNS clust index */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_INDEXES 44 <span class="comment">/* Root of SYS_INDEXES clust index */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_FIELDS 48 <span class="comment">/* Root of SYS_FIELDS clust index */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HDR_FSEG_HEADER 56 <span class="comment">/* Segment header for the tablespace</span></span></span><br><span class="line"><span class="meta"><span class="comment"></span></span></span><br><span class="line"><span class="meta"><span class="comment">segment into which the dictionary</span></span></span><br><span class="line"><span class="meta"><span class="comment"></span></span></span><br><span class="line"><span class="meta"><span class="comment">header is created */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中DICT_HDR_TABLES、DICT_HDR_TABLE_IDS、DICT_HDR_COLUMNS、DICT_HDR_INDEXES、DICT_HDR_FIELDS就分别对应INNODB_SYS_%这几个系统表聚集索引(DICT_HDR_TABLE_IDS是SYS_TABLES的二级索引page)。解析这几个page就可以得到对应系统表中的数据。</p>
<p>hexdump -C ibdata1 解析</p>
<p>从0开始的第7个page偏移量大小是1c000，从这里开始经过(FSEG_PAGE_DATA+ DICT_HDR_TABLES） 70字节，之后开始读取的内容即为这几个系统表对应的page号:</p>
<p>DICT_HDR_TABLES // 8</p>
<p>DICT_HDR_TABLE_IDS // 9</p>
<p>DICT_HDR_COLUMNS // 10</p>
<p>DICT_HDR_INDEXES // 11</p>
<p>DICT_HDR_FIELDS // 12</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/FIL_PAGE_TYPE_SYS.jpg" class="">

<h3 id="数据页解析"><a href="#数据页解析" class="headerlink" title="数据页解析"></a>数据页解析</h3><p>DICT_HDR_%对应的数据页类型为INDEX类型，INDEX结构如下:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/index_overview.jpg" class="">

<p>其中INDEX Header 结构如下:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/index_header.jpg" class="">

<p>上面这两张图中Nmuber of Directory Slots和Page Directory比较重要，Slots的作用是加快在页面内数据的查找速度，实现二分查找，通过解析Nmuber of Directory Slots可以得到page中总共有多少Slot，每个Slot为2个字节，存放相对于page的偏移量。</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/index_page_directory.jpg" class="">

<p>page从后向前读取Directory Slot 中的偏移量，实现二分查找，加快在页面中查找数据的速度 ，组成结构如下:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/page_directory_structure.jpg" class="">

<p>例如上图中总共有7个Slot， 存放的偏移量数据为[99, 221, 349, 477, 605, 733, 112]， 如果要查询K=10这条记录，只需要扫描[477，349]这两个偏移量对应的Slot即可找到对应的数据。每个Slot包含的记录数(4-8条记录)。</p>
<h3 id="记录解析"><a href="#记录解析" class="headerlink" title="记录解析"></a>记录解析</h3><p>现在知道了如何通过Page Directory定位数据，就需要知道每一条记录的存储结构了， MySQL 记录格式有新旧两种(Redundant Or Compact)，Index Header 中Number of Heap Records 的最高位如果是1就是Compact格式，否则是Redundant。</p>
<p>(storage/innobase/include/page0page.h)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_N_HEAP 4 <span class="comment">/* number of records in the heap,</span></span></span><br><span class="line"><span class="meta"><span class="comment"></span></span></span><br><span class="line"><span class="meta"><span class="comment">bit 15=flag: new-style compact page format */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不同的类型，存储结构也不相同，记录由header和data两部分组成</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/record_format.jpg" class="">

<p>header部分存放了记录长度信息和一些额外的信息，Redundant格式为6字节，Compact格式为5字节</p>
<p>(storage/innobase/include/rem0rec.ic)</p>
<p>这里我们解析的是ibdata1文件中的系统表，其格式都是Redundant，6个字节存储的内容如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Offsets of the bit-fields in an old-style record. NOTE! In the table the</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">most significant bytes and bits are written below less significant.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(1) byte offset (2) bit usage within byte</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">downward from</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">origin -&gt; 1 8 bits pointer to next record</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 8 bits pointer to next record</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3 1 bit short flag</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7 bits number of fields</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 3 bits number of fields</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 bits heap number</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 8 bits heap number</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 4 bits n_owned</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4 bits info bi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>通过这些额外信息可以得到:</p>
<ul>
<li><p>当前记录是否为delete记录</p>
</li>
<li><p>当前Slot中有几条记录</p>
</li>
<li><p>当前记录的类型， 如果heap number 为0是infimum，1是supremum，从2开始是用户记录</p>
</li>
<li><p>记录中有多个字段</p>
</li>
<li><p>变长字段存储格式(1 or 2 字节)</p>
</li>
<li><p>下一条记录的偏移量(相对于page)</p>
</li>
</ul>
<p>例如我们解析第8个page，也就是innodb_sys_tables中的内容:</p>
<p>第8个page对应的偏移量大小是0x20000</p>
<p>第9个page对应的偏移量大小是0x24000</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/slot_offset.jpg" class="">

<p>第8个page减去8个字节之后的2个字节就是第一个slot对应的值 00 65(16进制)= 101(10进制)，如下图:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/record_header.jpg" class="">

<p>从101向前读取6字节，就是record header信息，按规则解析，解析的代码示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">h.deleteFlag = (data[<span class="number">0</span>] &amp; <span class="number">0x20</span>) != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">h.minRecFlag = (data[<span class="number">0</span>] &amp; <span class="number">0x10</span>) != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">h.Owned = data[<span class="number">0</span>] &amp; <span class="number">0x0f</span></span><br><span class="line"></span><br><span class="line">h.heapNo |= <span class="keyword">uint16</span>(data[<span class="number">1</span>]) &lt;&lt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">h.heapNo |= <span class="keyword">uint16</span>(data[<span class="number">2</span>]&amp;<span class="number">0xf8</span>) &gt;&gt; <span class="number">3</span></span><br><span class="line"></span><br><span class="line">h.nField |= <span class="keyword">uint16</span>(data[<span class="number">2</span>]&amp;<span class="number">0x07</span>) &lt;&lt; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">h.nField |= <span class="keyword">uint16</span>(data[<span class="number">3</span>]&amp;<span class="number">0xfe</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">h.sFlag = (data[<span class="number">3</span>] &amp; <span class="number">0x1</span>) != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">h.nextRecorder = binary.BigEndian.Uint16(data[<span class="number">4</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>得到值为：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>deleteFlag</td>
<td>false</td>
</tr>
<tr>
<td>minRecFlag</td>
<td>false</td>
</tr>
<tr>
<td>Owned</td>
<td>1</td>
</tr>
<tr>
<td>heapNo</td>
<td>0</td>
</tr>
<tr>
<td>nField</td>
<td>1</td>
</tr>
<tr>
<td>sFlag</td>
<td>true</td>
</tr>
<tr>
<td>nextRecorder</td>
<td>366</td>
</tr>
</tbody></table>
<p>这可以知道记录类型是infimum， 下一条记录的Offset是366。</p>
<p>偏移量366对应的前6个字节内容如下:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/record_header2.jpg" class="">

<p>解析后的值:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>deleteFlag</td>
<td>false</td>
</tr>
<tr>
<td>minRecFlag</td>
<td>false</td>
</tr>
<tr>
<td>Owned</td>
<td>0</td>
</tr>
<tr>
<td>heapNo</td>
<td>5</td>
</tr>
<tr>
<td>nField</td>
<td>10</td>
</tr>
<tr>
<td>sFlag</td>
<td>true</td>
</tr>
<tr>
<td>nextRecorder</td>
<td>141</td>
</tr>
</tbody></table>
<p>得到这条记录有10个字段，向前读取10个字节: 3a b6 36 32 2a 26 22 1a 13 0d， 就是字段的偏移量，通过偏移量就可以从fieldOffset位置处开始解析每一个字段的值。下面这个图更为直观一些</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/record_struct.jpg" class="">

<p>解析这10个字节就可以得到每个字段的长度，[13,6,7,8,4,4,8,4,0,4]， 解析大致方式是判断最高位是否为1，如果不为1就取后7位，并用当前字段的解析值减去前一个字段的解析值即得到这个字段的长度，例如:</p>
<p>3a b6 36 32 2a 26 22 1a 13 0d</p>
<p>0d = 0000 1101</p>
<p>13 = 0001 0011</p>
<p>这两个字段都不为空，所以第一个字段的长度是13 ， 第二个字段长度是19 - 13 = 6</p>
<p>通过每个字段的长度，再从fieldOffset位置处开始解析出每个字段的值:</p>
<p>sys_tables聚集索引的定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> dict_fld_sys_tables_enum &#123;</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESNAME = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESDB_TRX_ID = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESDB_ROLL_PTR = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESID = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESN_COLS = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESTYPE = <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESMIX_ID = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESMIX_LEN = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESCLUSTER_ID = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line">DICT_FLDSYS_TABLESSPACE = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">DICT_NUM_FIELDS__SYS_TABLES = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>解析方法可参考函数(storage/innobase/dict/dict0load.cc)dict_sys_tables_rec_read，解析后的值:</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>DICT_FLD__SYS_TABLES_NAME</td>
<td>SYS_DATAFILES</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_DB_TRX_ID</td>
<td>769</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_DB_ROLL_PTR</td>
<td>45317471250485761</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_ID</td>
<td>14</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_N_COLS</td>
<td>2</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_TYPE</td>
<td>1</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_MIX_ID</td>
<td>0</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_MIX_LEN</td>
<td>64</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_CLUSTER_ID</td>
<td>null</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_SPACE</td>
<td>0</td>
</tr>
</tbody></table>
<p>与查询INNODB_SYS_TABLES表中的记录做个对比:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/sys_tables1.jpg" class="">

<p>表中查询出的n_cols是5，但我们解析出来的是2，原因是表中查询会把三个隐藏字段也计算在内(DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID)。</p>
<p>file_format与row_format如何的出来的呢？</p>
<p>n_cols的第32位代表row_format格式，如果为1就是COMPACT。</p>
<p>file_format会比较特殊一些， 需要根据解析出来的type和n_cols共同计算完成，代码中是这样写的(storage/innobase/include/dict0dict.ic):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Convert a <span class="number">32</span> bit integer from SYS_TABLES.TYPE to <span class="keyword">dict_table_t</span>::flags</span><br><span class="line"></span><br><span class="line">The following chart shows the translation of the low order bit.</span><br><span class="line"></span><br><span class="line">Other bits are the same.</span><br><span class="line"></span><br><span class="line">========================= Low order bit ==========================</span><br><span class="line"></span><br><span class="line">| REDUNDANT | COMPACT | COMPRESSED <span class="keyword">and</span> DYNAMIC</span><br><span class="line"></span><br><span class="line">SYS_TABLES.TYPE | <span class="number">1</span> | <span class="number">1</span> | <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dict_table_t</span>::flags | <span class="number">0</span> | <span class="number">1</span> | <span class="number">1</span></span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line"></span><br><span class="line">@<span class="keyword">return</span> ulint containing SYS_TABLES.TYPE */</span><br><span class="line"></span><br><span class="line">UNIV_INLINE</span><br><span class="line"></span><br><span class="line">ulint</span><br><span class="line"></span><br><span class="line">dict_sys_tables_type_to_tf(</span><br><span class="line"></span><br><span class="line">/=======================/</span><br><span class="line"></span><br><span class="line">ulint type, <span class="comment">/*!&lt; in: SYS_TABLES.TYPE field */</span></span><br><span class="line"></span><br><span class="line">ulint n_cols) <span class="comment">/*!&lt; in: SYS_TABLES.N_COLS field */</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ulint flags;</span><br><span class="line"></span><br><span class="line">ulint redundant = !(n_cols &amp; DICT_N_COLS_COMPACT); <span class="comment">// 判断是redundant还是COMPACT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adjust bit zero. */</span></span><br><span class="line"></span><br><span class="line">flags = redundant ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ZIP_SSIZE, ATOMIC_BLOBS &amp; DATA_DIR are the same. */</span></span><br><span class="line"></span><br><span class="line">flags |= type &amp; (DICT_TF_MASK_ZIP_SSIZE</span><br><span class="line"></span><br><span class="line">| DICT_TF_MASK_ATOMIC_BLOBS</span><br><span class="line"></span><br><span class="line">| DICT_TF_MASK_DATA_DIR</span><br><span class="line"></span><br><span class="line">| DICT_TF_MASK_SHARED_SPACE); <span class="comment">//除了最低位，用相应的标志位与type做 &#x27;&amp;&#x27;运算，判断是否存在这些属性，最后存放在flags中</span></span><br><span class="line"></span><br><span class="line">ut_ad(!DICT_TF_GET_ZIP_SSIZE(flags) || DICT_TF_HAS_ATOMIC_BLOBS(flags));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(flags);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>字段名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>DICT_FLD__SYS_TABLES_N_COLS</td>
<td>2</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_TYPE</td>
<td>1</td>
</tr>
</tbody></table>
<p>n_cols为2第32位是0 ， 所以redundant=1，flags的低位是0</p>
<p>type为1，经过与相应的标志位做’&amp;’运算后，所有位都为0，最后的flags即是0，用一张图解释:</p>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/flags1.jpg" class="">

<p>查询的时候做相应的转换，判断file_format类型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">i_s_dict_fill_sys_tables(</span><br><span class="line"></span><br><span class="line">/=====================/</span><br><span class="line"></span><br><span class="line">THD* thd, <span class="comment">/*!&lt; in: thread */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dict_table_t</span>* table, <span class="comment">/*!&lt; in: table */</span></span><br><span class="line"></span><br><span class="line">TABLE* table_to_fill) <span class="comment">/*!&lt; in/out: fill this table */</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Field** fields;</span><br><span class="line"></span><br><span class="line">ulint compact = DICT_TF_GET_COMPACT(table-&gt;flags); <span class="comment">//获取compact标志位</span></span><br><span class="line"></span><br><span class="line">ulint atomic_blobs = DICT_TF_HAS_ATOMIC_BLOBS(</span><br><span class="line"></span><br><span class="line">table-&gt;flags); <span class="comment">//获取atomic_blobs标志位，这个标志就代表了对于 blob or text field 做页外存储，也就代表file_format是Barracuda</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">page_size_t</span>&amp; page_size = dict_tf_get_page_size(table-&gt;flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* file_format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* row_format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* space_type;</span><br><span class="line"></span><br><span class="line">file_format = trx_sys_file_format_id_to_name(atomic_blobs); <span class="comment">//可以参考file_format_name_map，是一个指针数组，下标0代表Antelope，下标1代表Barracuda</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!compact) &#123;</span><br><span class="line"></span><br><span class="line">row_format = <span class="string">&quot;Redundant&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!atomic_blobs) &#123;</span><br><span class="line"></span><br><span class="line">row_format = <span class="string">&quot;Compact&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (DICT_TF_GET_ZIP_SSIZE(table-&gt;flags)) &#123;</span><br><span class="line"></span><br><span class="line">row_format = <span class="string">&quot;Compressed&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">row_format = <span class="string">&quot;Dynamic&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_system_tablespace(table-&gt;space)) &#123;</span><br><span class="line"></span><br><span class="line">space_type = <span class="string">&quot;System&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (DICT_TF_HAS_SHARED_SPACE(table-&gt;flags)) &#123;</span><br><span class="line"></span><br><span class="line">space_type = <span class="string">&quot;General&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">space_type = <span class="string">&quot;Single&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略无用代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>compact为0，!compact即为1，所以row_format为Redundant</p>
<p>同时atomic_blobs为0 ， file_format即为Antelope</p>
<ul>
<li>再用以上规则解析一条非系统表记录</li>
</ul>
<table>
<thead>
<tr>
<th>字段名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>DICT_FLD__SYS_TABLES_NAME</td>
<td>dhy/dhytest2</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_DB_TRX_ID</td>
<td>27446</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_DB_ROLL_PTR</td>
<td>46161896180619265</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_ID</td>
<td>45</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLE_N_COLS</td>
<td>2147483650</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_TYPE</td>
<td>33</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_MIX_ID</td>
<td>0</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_MIX_LEN</td>
<td>80</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_CLUSTER_ID</td>
<td>null</td>
</tr>
<tr>
<td>DICT_FLD__SYS_TABLES_SPACE</td>
<td>82</td>
</tr>
</tbody></table>
<img src="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/flags2.jpg" class="">

<p>n_cols为2第32位是1 ， 所以redundant=0，flags的低位是1</p>
<p>type为33，对应的二进制是:0010 0001，经过与相应的标志位做’&amp;’运算后，对应的二进制为:0010 0000，在与flags做’|’操作后，二进制为:0010001，则atomic_blobs和compact为1，对应的file_format则是Barracuda， row_format是Dynamic</p>
<p>同时n_cols 第32位的标志位需要取消，n_cols即为2了。</p>
<p>与查询表中得到的信息是一致的:</p>
<p>&lt;!–￼14–&gt;</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了Innodb系统表空间基本的结构，及如何解析ibdata表空间中的记录。通过翻阅资料和MySQL代码的查看，学习到很多技巧，例如:位移操作、逻辑运算、如何节省空间等。后面会再写一篇关于系统表加载的文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/" data-id="ckdyc8e370001rluuenbfecvq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Innodb/" rel="tag">Innodb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL中如何控制SQL在测试-生产环境具有相同的执行路径" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/" class="article-date">
  <time datetime="2020-06-08T03:00:58.000Z" itemprop="datePublished">2020-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/">MySQL中如何控制SQL在测试-生产环境具有相同的执行路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL中如何控制SQL具有相同执行路径"><a href="#MySQL中如何控制SQL具有相同执行路径" class="headerlink" title="MySQL中如何控制SQL具有相同执行路径"></a>MySQL中如何控制SQL具有相同执行路径</h1><blockquote>
<p>最近有客户提出一个比较有意思的问题，生产环境与测试环境数据量相差比较大，导致两个环境中执行路径大不相同，如何能保证这两个环境执行计划相同呢？</p>
</blockquote>
<blockquote>
<p> 这还是一个比较实际的需求，MySQL中没有绑定执行计划功能，并且有时候测试环境与生产环境执行路径不同，可能会引发线上的故障。</p>
</blockquote>
<blockquote>
<p>能想到的一种方式就是将MySQL中持久化统计信息表进行同步，这样达到两个环境执行路径相同</p>
</blockquote>
<h2 id="想法验证"><a href="#想法验证" class="headerlink" title="想法验证"></a>想法验证</h2><p>验证方法的可行性，通过一个实验做验证，大致步骤如下:</p>
<ol>
<li><p>表中插入10万条数据，执行一条查询，记录下执行计划</p>
</li>
<li><p>查看mysql.innodb_index_stats中的统计信息，并导出</p>
</li>
<li><p>删除表中数据</p>
</li>
<li><p>手工收集一次统计信息，之后将innodb_stats_auto_recalc设置为off，为了防止之后自动收集统计信息</p>
</li>
<li><p>插入5万条数据，执行一条查询，记录下执行计划</p>
</li>
<li><p>导入步骤2中记录下来的统计信息后，再次查看执行计划，是否与步骤1中的相同</p>
</li>
</ol>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol>
<li>创建表及插入函数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t ( <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,a <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, b <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>), <span class="keyword">KEY</span> a (a), <span class="keyword">KEY</span> b (b)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata() <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">declare i int; set i=1; while(i&lt;=100000)do</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>; <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>插入数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; call idata();</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (10 min 9.89 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>查看统计信息及执行计划</li>
</ol>
<img src="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E5%90%8E%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF.jpg" class="">

<img src="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%92%E5%85%A5%E5%90%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.jpg" class="">

<p>将统计信息用mysqldump导出</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqldump <span class="comment">--host=127.0.0.1--port=3322 --user=root --password=123456 --databases mysql --tables innodb_index_stats --where &quot;table_name = &#x27;t&#x27;&quot;</span></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>删除表数据，集统计信息，关闭统计信息自动收集</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from t;</span><br><span class="line"></span><br><span class="line">Query OK, 100000 rows affected (0.68 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; analyze table dhy.t;</span><br><span class="line"></span><br><span class="line">mysql&gt; set global innodb_stats_auto_recalc = off; //关闭统计信息持久化收集</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这时对应的统计信息如下:</p>
<img src="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF.jpg" class="">

<ol start="5">
<li>再次插入数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; call idata();</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (5 min 10.59 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这时再执行相同的查询，就会看到走不到索引了:</p>
<img src="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%8E%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF.jpg" class="">

<ol start="6">
<li>导入统计信息</li>
</ol>
<p>将原有的统计信息删除，并导入备份出来的统计信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete from innodb_index_stats where table_name = &#x27;t&#x27;; Query OK, 11 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO innodb_index_stats VALUES (&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;PRIMARY&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_diff_pfx01&#x27;,100256,20,&#x27;id&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;PRIMARY&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_leaf_pages&#x27;,208,NULL,&#x27;Number of leaf pages in the index&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;PRIMARY&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;size&#x27;,225,NULL,&#x27;Number of pages in the index&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;a&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_diff_pfx01&#x27;,100557,20,&#x27;a&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;a&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_diff_pfx02&#x27;,100710,20,&#x27;a,id&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;a&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_leaf_pages&#x27;,90,NULL,&#x27;Number of leaf pages in the index&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;a&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;size&#x27;,97,NULL,&#x27;Number of pages in the index&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;b&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_diff_pfx01&#x27;,100710,20,&#x27;b&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;b&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_diff_pfx02&#x27;,100557,20,&#x27;b,id&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;b&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;n_leaf_pages&#x27;,90,NULL,&#x27;Number of leaf pages in the index&#x27;),(&#x27;dhy&#x27;,&#x27;t&#x27;,&#x27;b&#x27;,&#x27;2020-06-05 09:44:32&#x27;,&#x27;size&#x27;,97,NULL,&#x27;Number of pages in the index&#x27;);</span><br><span class="line"></span><br><span class="line">Query OK, 11 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">Records: 11 Duplicates: 0 Warnings: 0</span><br><span class="line"></span><br><span class="line">同时需要把innodb_table_stats表中的n_rows修改为10万</span><br><span class="line"></span><br><span class="line">mysql&gt; update innodb_table_stats set n_rows = 100000 where table_name = &#x27;t&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>导入之后直接执行语句，还是走不到索引，通过show index from t;可以看到索引的统计信息还没有更新，需要执行一次flush table(线上谨慎执行或者不建议操作)，将统计信息从持久化磁盘上刷新到内存中。</p>
<p>flush table 前:</p>
<img src="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/flush_table%E5%89%8D.jpg" class="">



<p>flsuh table 后:</p>
<img src="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/flush_table%E5%90%8E.jpg" class="">



<p>看到这里已经走到了索引，可以达到我们想要的结果了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过更新Innodb两张持久化统计信息表，能够达到测试环境与生产环境具有相同的执行路径，需要注意的是，当再次analyze后还是会重新收集统计信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/" data-id="ckdyc8e3g0007rluugf3bb0md" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RC隔离级别下，死锁案例分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-04-04T06:12:25.000Z" itemprop="datePublished">2020-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/">RC隔离级别下，死锁案例分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RC隔离级别下，死锁案例分析"><a href="#RC隔离级别下，死锁案例分析" class="headerlink" title="RC隔离级别下，死锁案例分析"></a>RC隔离级别下，死锁案例分析</h1><blockquote>
<p>文章的产生是因为生产上遇到一个死锁案例，根据此案例分析引申出比较多的内容，故总结一下</p>
</blockquote>
<h2 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h2><ul>
<li>数据库版本: MySQL 5.6.39社区版</li>
<li>事务隔离级别: RC</li>
<li>死锁日志</li>
</ul>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/A0776CC9-8567-4725-8A6C-494DB0BA713B.png" class="">
<p>这个死锁日志中，可以得到上锁信息如下:</p>
<ol>
<li>事务28608410 ， 申请X类型记录锁时，发生了锁等待，对应的记录就是user_id=195578这条(16进制的2fbfa就是195578)</li>
<li>事务28608409持有user_id=195578这条记录上的X类型记录锁时</li>
<li>事务28608409， 申请S类型的Next-Key Lock时发生了所等待，对应user_id=195578这条记录</li>
</ol>
<p>RC隔离级别下理论上不应该存在Nexy-Lock的，为什么这里会出现S类型的Next-Lock呢？我们先不考虑这问题，先单纯的分析这个死锁。</p>
<p>上面的死锁对应操作如下:</p>
<table>
<thead>
<tr>
<th>事务28608409</th>
<th>事务28608410</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction</td>
<td></td>
</tr>
<tr>
<td>delete from user_photo_info where user_id = 195578;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from user_photo_info where user_id = 195578;</td>
</tr>
<tr>
<td>INSERT INTO user_photo_info (user_id, user_photo) VALUES (195578, ‘省略值’);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
</tr>
</tbody></table>
<p> 针对上面这个死锁，有些奇怪:</p>
<ul>
<li><p>为什么事务28608409申请S类型的Next-Key Lock时会发生死锁呢？是和谁冲突的呢？感觉不像是和事务28608410发生的冲突，因为28608409还没有结束，那么X类型的记录锁也申请不到。感觉这种情况下不应该发生死锁的，并且发现在8.0.18版本中进行同样的测试，就不会发现死锁问题。<br>查询了最近8.0版本的Release Notes，在8.0.18版本中有一个bug修复:</p>
<ul>
<li><p>InnoDB: A deadlock was possible when a transaction tries to upgrade a record lock to a next key lock. (Bug #23755664, Bug #82127)</p>
<p>对应bug地址:</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=82127">https://bugs.mysql.com/bug.php?id=82127</a></p>
</li>
</ul>
</li>
</ul>
<p>大概意思就是在某些情况下，锁升级问题导致了死锁。现象来看是bug导致，但通过show engine innodb status\G，查看加锁情况，就会发现还是有S类型的Next-Key Lock加锁成功的:</p>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/1278B162-EF56-436C-BAAA-1AF2CDAEB8EB.png" class="">
<p>这里会发现在supremum添加S类型的Next-Key Lock加锁成功的，还要继续分析为何会添加这个S类型的Next-Key Lock。</p>
<ul>
<li>注意:<br>下面的分析就与此bug无关，因为RC隔离级别下某些情况确实会加S类型的Next-Key Lock。主要是看下为何会加S Next-Key Lock和一些延伸。</li>
</ul>
<h2 id="为何要添加S类型的间隙锁"><a href="#为何要添加S类型的间隙锁" class="headerlink" title="为何要添加S类型的间隙锁"></a>为何要添加S类型的间隙锁</h2><p>MySQL中间隙锁是在RR隔离级别下才会有，为何RC情况下也会出现？官方文档中也有说过，如果insert时候，有唯一性索引检测到冲突，会添加S类型Nexy-Key Lock 锁。看一个例子:</p>
<ul>
<li>测试环境MySQL-8.0.19<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (<span class="keyword">id</span> <span class="built_in">int</span> );</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_uni_id <span class="keyword">on</span> t1 (<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
session1|session2|session3</li>
</ul>
<p>——–|———|———–<br>begin;|||<br>DELETE FROM t1 WHERE id = 1;||<br> |begin;<br> |insert into t1 values(1);//等待|<br> ||begin;<br> ||insert into t1 values(1); //等待<br> commit;||</p>
<p>这里还需要两个概念:</p>
<p> 唯一约束检测原则:</p>
<ul>
<li>当发生唯一索引约束冲突时，会对当前记录和当前记录的下一条添加S类型Next-Key Lock</li>
</ul>
<p>插入意向锁:</p>
<ul>
<li>文档中关于插入意向锁的描述，简单说就是:插入意向锁直接是不冲突的，插入意向锁也是一种间隙锁，提高并发插入。</li>
<li>但还有一点就是申请插入意向锁时，会检查插入记录位置的下一条记录上是否持有锁，如果有,则判断是否与插入意向锁冲突</li>
</ul>
<p> 如果这里添加的不是S类型Next-Key Lock锁，会出现主键失效的情况， 假设添加的是S NOT GAP锁，情况如下:</p>
<ul>
<li><p>session1 添加X类型记录锁</p>
</li>
<li><p>session2 添加S NOT GAP锁 //等待</p>
</li>
<li><p>session3 添加S NOT GAP锁 //等待</p>
<p>由于session1还没有提交，所以会做唯一性约束检查，申请S NOT GAP锁(假设)。当session1执行commit后，session2和session3获得S NOT GAP 锁(假设), 并且session2和session3同时会对下一条记录添加S NOT GAP 锁(假设)，这时session2检查插入记录的下一条时发现有S NOT GAP锁，不与插入意向锁冲突，则插入成功，同理session3也会做相应的检查，但也不会发生冲突，所以两条记录都会插入成功。</p>
<p>所以这里需要添加S类型的Next-Key Lock，这样插入意向锁就会发生冲突，在一些场景下就会触发死锁，例如这个例子，死锁日志如下:</p>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/6FCDD950-C8F9-4D02-B09B-4867E7972779.png" class=""> 



</li>
</ul>
<p>这里事务120495申请插入supremum上的插入意向锁时发生了锁等待，因为事务120496在supremum上添加了S类型的Next-Key Lock，并且事务120496申请supremum上的插入意向锁时发生了冲突，这样就造成了死锁。</p>
<p>这里为何说是一些场景情况下， 因为我发现测试中也有不会发生死锁现象的时候，分别看下出现死锁和没有出现死锁时performance_schema.data_locks上的加锁情况:</p>
<ul>
<li><p>当发生锁等待时:</p>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/4F4626D6-8241-454D-AEB4-7C3587869AFB.png" class="">
<p>session2,session3都会申请S类型的Next-Key Lock，与X类型的记录锁发生锁冲突，等待。</p>
</li>
<li><p>出现死锁时的情况</p>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/F315CA99-3F20-4BD7-B23B-76841E2AFE17.png" class="">

<p>由于出现了死锁，这里看到的就是留下来的事务加锁的信息，这里能看到个(S,GAP)，这个后面讲锁继承和锁迁移时会说到。</p>
</li>
<li><p>没有出现死锁情况</p>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/A45C2DCE-8065-4B6C-B25B-AA104CBFC50C.png" class="">
<p>没有出现死锁情况从上锁信息来看，像是session2和session3中，有一个执行的很快，首先在id=1这条记录上添加了X类型的记录锁，导致另外一个会话申请S类型的Next-Key Lock时发生了锁锁等待，从而没有导致死锁发生。但当中还有一点没有搞明白的是，为何S类型的GAP锁会发生锁等待，并且thread_id看起来也很奇怪。</p>
</li>
</ul>
<h3 id="代码上的补充说明"><a href="#代码上的补充说明" class="headerlink" title="代码上的补充说明"></a>代码上的补充说明</h3><p>在做插入时首先会做唯一性约束检查，在函数row_ins_scan_sec_index_for_duplicate中，大致内容如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  省略若干代码</span><br><span class="line">   <span class="keyword">const</span> ulint lock_type =</span><br><span class="line">        index-&gt;table-&gt;skip_gap_locks() ? LOCK_REC_NOT_GAP : LOCK_ORDINARY; <span class="comment">//如果锁操作的表，是不允许跳过间隙锁的，则lock_type就是LOCK_ORDINARY --Next-Key Lock</span></span><br><span class="line">  省略若干代码</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index-&gt;table-&gt;skip_gap_locks()) &#123;</span><br><span class="line">        <span class="comment">/* Only GAP lock is possible on supremum. */</span></span><br><span class="line">        <span class="keyword">if</span> (page_rec_is_supremum(rec)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp_dtuple_rec(entry, rec, index, offsets) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">goto</span> end_scan;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      err = row_ins_set_rec_lock(LOCK_S, lock_type, block, rec, index, offsets,</span><br><span class="line">                                 thr); <span class="comment">//添加LOCK_S锁，lock_type=0 ,也就是S类型的Next-Key Lock</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">case</span> DB_SUCCESS_LOCKED_REC:</span><br><span class="line">        err = DB_SUCCESS;</span><br><span class="line">      <span class="keyword">case</span> DB_SUCCESS:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">goto</span> end_scan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page_rec_is_supremum(rec)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmp = cmp_dtuple_rec(entry, rec, index, offsets);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span> &amp;&amp; !index-&gt;allow_duplicates) &#123;</span><br><span class="line">      <span class="keyword">if</span> (row_ins_dupl_error_with_rec(rec, entry, index, offsets)) &#123; <span class="comment">// 如果冲突检测到两条记录一样，则判断下记录是否是标记为delete的，有可能记录delete了但是还没有被purge线程purge</span></span><br><span class="line">        err = DB_DUPLICATE_KEY;</span><br><span class="line"></span><br><span class="line">        thr_get_trx(thr)-&gt;error_index = index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the duplicate is on hidden FTS_DOC_ID,</span></span><br><span class="line"><span class="comment">        state so in the error log */</span></span><br><span class="line">        <span class="keyword">if</span> (index == index-&gt;table-&gt;fts_doc_id_index &amp;&amp;</span><br><span class="line">            DICT_TF2_FLAG_IS_SET(index-&gt;table, DICT_TF2_FTS_HAS_DOC_ID)) &#123;</span><br><span class="line">          ib::error(ER_IB_MSG_958) &lt;&lt; <span class="string">&quot;Duplicate FTS_DOC_ID&quot;</span></span><br><span class="line">                                      <span class="string">&quot; value on table &quot;</span></span><br><span class="line">                                   &lt;&lt; index-&gt;table-&gt;name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> end_scan;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ut_a(cmp &lt; <span class="number">0</span> || index-&gt;allow_duplicates);</span><br><span class="line">      <span class="keyword">goto</span> end_scan;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (btr_pcur_move_to_next(&amp;pcur, mtr)); <span class="comment">// 继续取下一条记录</span></span><br></pre></td></tr></table></figure>
<p>这里还有个问题就是为何还要获取下一条记录呢？这个可以阅读下文章最后面的参考连接(4.5.6)，网易温正湖老师的三篇文章。</p>
<p>冲突检测后，会进入lock_rec_insert_check_and_lock函数，主要作用就是检测，插入记录的下一条记录是否存在锁，如果存在是为与插入意向锁冲突:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ulint heap_no = page_rec_get_heap_no(next_rec); <span class="comment">//读取当前记录的下一条，获取heap_no</span></span><br><span class="line"> <span class="comment">//省略若干代码</span></span><br><span class="line">  lock = lock_rec_get_first(lock_sys-&gt;rec_hash, block, heap_no); <span class="comment">//查看是否有锁存在</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//省略若干代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略若干代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If another transaction has an explicit lock request which locks</span></span><br><span class="line"><span class="comment">  the gap, waiting or granted, on the successor, the insert has to wait.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  An exception is the case where the lock by the another transaction</span></span><br><span class="line"><span class="comment">  is a gap type lock which it placed to wait for its turn to insert. We</span></span><br><span class="line"><span class="comment">  do not consider that kind of a lock conflicting with our insert. This</span></span><br><span class="line"><span class="comment">  eliminates an unnecessary deadlock which resulted when 2 transactions</span></span><br><span class="line"><span class="comment">  had to wait for their insert. Both had waiting gap type lock requests</span></span><br><span class="line"><span class="comment">  on the successor, which produced an unnecessary deadlock. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ulint type_mode = LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">lock_t</span> *wait_for =</span><br><span class="line">      lock_rec_other_has_conflicting(type_mode, block, heap_no, trx); <span class="comment">//添加插入意向锁，判断是否冲突</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="隐式锁、锁继承、锁分裂"><a href="#隐式锁、锁继承、锁分裂" class="headerlink" title="隐式锁、锁继承、锁分裂"></a>隐式锁、锁继承、锁分裂</h2><blockquote>
<p>先看一些后面文章中会用到的内容, 涉及到锁类型和锁模式，还有一些数字，其定义如下:<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">enum</span> lock_mode &#123;</span><br><span class="line">    LOCK_IS = <span class="number">0</span>, <span class="comment">/* intention shared */</span></span><br><span class="line">    LOCK_IX, <span class="comment">/* intention exclusive */</span></span><br><span class="line">    LOCK_S, <span class="comment">/* shared */</span></span><br><span class="line">    LOCK_X, <span class="comment">/* exclusive */</span></span><br><span class="line">    LOCK_AUTO_INC, <span class="comment">/* locks the auto-inc counter of a table</span></span><br><span class="line"><span class="comment">            in an exclusive mode */</span></span><br><span class="line">    LOCK_NONE, <span class="comment">/* this is used elsewhere to note consistent read */</span></span><br><span class="line">    LOCK_NUM = LOCK_NONE, <span class="comment">/* number of lock modes */</span></span><br><span class="line">    LOCK_NONE_UNSET = <span class="number">255</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_TABLE 16 <span class="comment">/*!&lt; table lock */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_REC 32   <span class="comment">/*!&lt; record lock */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_WAIT   256        <span class="comment">/* 表示正在等待锁 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_ORDINARY 0     <span class="comment">/* 表示 next-key lock ，锁住记录本身和记录之前的 gap*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_GAP    512        <span class="comment">/* 表示锁住记录之前 gap（不锁记录本身） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_REC_NOT_GAP 1024    <span class="comment">/* 表示锁住记录本身，不锁记录前面的 gap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_INSERT_INTENTION 2048    <span class="comment">/* 插入意向锁 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONV_BY_OTHER 4096        <span class="comment">/* 表示锁是由其它事务创建的(比如隐式锁转换) */</span></span></span><br><span class="line"></span><br><span class="line"> 例如文中提到的，<span class="number">546</span>= LOCK_GAP|LOCK_REC|LOCK_S(<span class="number">512</span>+<span class="number">32</span>+<span class="number">2</span>) = S,GAP</span><br><span class="line"></span><br><span class="line"> heap_no是记录在物理文件中的位置编号，是物理位置，例如有可能是这样存储:</span><br><span class="line"></span><br><span class="line">heap_no :   <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> 存储的值:    <span class="number">2</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line"> heap_no  = <span class="number">1</span>代表supermum</span><br><span class="line"> heap_no = <span class="number">0</span> 代表infimum</span><br><span class="line"> 我们插入的数据都是从heap_no = <span class="number">2</span>开始计算</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的例子中，我们会看到有S类型的GAP锁出现，这里面涉及到了锁继承和锁分裂，这里我们解释一下:</p>
<p>正常的插入时，不会添加锁的，除非发生有唯一性冲突检测时会添加S类型的Next-Key Lock，通过一个例子来感受下:<br>session1 开启会话，执行insert语句，这时查看performance_schema.data_locks表，只能看到一个表上的意向锁(IX),但如果session 2 开启会话，执行同样的insert语句，就会看到如下结果:</p>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/769EDCB6-ED00-484A-B662-626003733A86.png" class="">
<p>这里看到表上有了X，REC_NOT_GAP也就是记录锁，但是仔细看会发现thread_id是81，81是session2的线程ID，<strong>这就是隐式锁</strong>，因为这里的X，REC_NOT_GAP记录锁是session2会话构建的。<br>还有两个圈红的地方是数值3，代表的heap_no，下面会用到。</p>
<p>涉及到GAP锁时，会有锁继承和锁分裂现象，看下面这个例子:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (<span class="keyword">id</span> <span class="built_in">int</span> );</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_uni_id <span class="keyword">on</span> t1 (<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t1 values(1);</td>
</tr>
<tr>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>insert into t1 values(1);//等待</td>
</tr>
<tr>
<td>rollback;</td>
<td></td>
</tr>
</tbody></table>
<p>查看performance_schema.data_locks表:<br>当执行rollback之前的加锁情况，这时能看到申请S类型Next-Key Lock发生了锁冲突</p>
<img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/769EDCB6-ED00-484A-B662-626003733A86.png" class="">
<p>执行rollback之后情况如下:<br> <img src="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/AB2F5D24-1E08-4C02-8D8B-090AE16C3C49.png" class=""><br> 这里的锁模式都是S类型的间隙锁，这是如何来的呢？看thread_id是80，那就是session1创建的。执行rollback时候，gdb查看到信息如下:</p>
<ul>
<li><p>这里主要看这里: <em>lock_rec_inherit_to_gap(heir_block=0x000000012b837a80,block=0x000000012b837a80, heir_heap_no=2, heap_no=3)</em><br>将heap_no=3继承给heap_no=2,  type_mode=546(S,GAP) , heap_no=3就是插入id=1这条记录</p>
<ul>
<li>锁继承是当原有记录被删除时，需要将原记录上的GAP属性继承给下一条记录。例如:表中有两条记录(1,2),原有的GAP锁加在(-oo,1)上，当记录1被删除后，要保证GAP锁能继续起到锁住这段范围的作用，就会将GAP锁继承给记录2，也就是变成了(-oo,2)。<br>所以这里session1执行了rollback后，会将原有记录上申请S类型的Next-Key Lock的GAP属性继承给下一条记录。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread #42, stop reason &#x3D; breakpoint 56.2</span><br><span class="line"> * frame #0: 0x000000010c2e94f0 mysqld&#96;lock_rec_set_nth_bit(lock&#x3D;0x00007fb758839778, i&#x3D;2) at lock0priv.ic:83:3</span><br><span class="line">   frame #1: 0x000000010c2e91ac mysqld&#96;RecLock::lock_alloc(trx&#x3D;0x000000012b2bf060, index&#x3D;0x00007fb7587c6c88, mode&#x3D;546, rec_id&#x3D;0x00007000071ab1a8, size&#x3D;9) at lock0lock.cc:1033:3</span><br><span class="line">   frame #2: 0x000000010c2ea030 mysqld&#96;RecLock::create(this&#x3D;0x00007000071ab180, trx&#x3D;0x000000012b2bf060, add_to_hash&#x3D;true, prdt&#x3D;0x0000000000000000) at lock0lock.cc:1308:18</span><br><span class="line">   frame #3: 0x000000010c2ecc72 mysqld&#96;lock_rec_add_to_queue(type_mode&#x3D;546, block&#x3D;0x000000012b837a80, heap_no&#x3D;2, index&#x3D;0x00007fb7587c6c88, trx&#x3D;0x000000012b2bf060, we_own_trx_mutex&#x3D;false) at lock0lock.cc:1551:12</span><br><span class="line">   frame #4: 0x000000010c2edd3c mysqld&#96;lock_rec_inherit_to_gap(heir_block&#x3D;0x000000012b837a80, block&#x3D;0x000000012b837a80, heir_heap_no&#x3D;2, heap_no&#x3D;3) at lock0lock.cc:2625:7</span><br><span class="line">   frame #5: 0x000000010c2eead3 mysqld&#96;lock_update_delete(block&#x3D;0x000000012b837a80, rec&#x3D;&quot;\x80&quot;) at lock0lock.cc:3443:3</span><br><span class="line">   frame #6: 0x000000010be4b211 mysqld&#96;btr_cur_optimistic_delete_func(cursor&#x3D;0x00007000071ab8a8, flags&#x3D;0, mtr&#x3D;0x00007000071ab9e0) at btr0cur.cc:4616:5</span><br><span class="line">   frame #7: 0x000000010c5560c5 mysqld&#96;row_undo_ins_remove_sec_low(mode&#x3D;16386, index&#x3D;0x00007fb7587c6c88, entry&#x3D;0x00007fb75603f2b8, thr&#x3D;0x00007fb75a3af210, node&#x3D;0x00007fb75916c2b8) at row0uins.cc:245:11</span><br><span class="line">  省略 ......</span><br></pre></td></tr></table></figure>

<ul>
<li>下面执行insert插入时候，会将原有的一个间隙锁，分裂成两个(锁分裂)，例如原有的GAP是加在了(1,5)上，现在插入一条记录3，则会变成(-oo,3),(3,5)这两个GAP锁:<br>heap_no=3上的锁从heap_no=2上分裂过来 ， heap_no=3也就是session2中插入id=1这条记录 <em>lock_rec_inherit_to_gap_if_gap_lock(block=0x000000012b837a80, heir_heap_no=3, heap_no=2)</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread #39, stop reason &#x3D; breakpoint 56.2</span><br><span class="line"> * frame #0: 0x000000010c2e94f0 mysqld&#96;lock_rec_set_nth_bit(lock&#x3D;0x00007fb758839778, i&#x3D;3) at lock0priv.ic:83:3</span><br><span class="line">   frame #1: 0x000000010c2ecbd1 mysqld&#96;lock_rec_add_to_queue(type_mode&#x3D;546, block&#x3D;0x000000012b837a80, heap_no&#x3D;3, index&#x3D;0x00007fb7587c6c88, trx&#x3D;0x000000012b2bf060, we_own_trx_mutex&#x3D;false) at lock0lock.cc:1538:9</span><br><span class="line">   frame #2: 0x000000010c2ee956 mysqld&#96;lock_rec_inherit_to_gap_if_gap_lock(block&#x3D;0x000000012b837a80, heir_heap_no&#x3D;3, heap_no&#x3D;2) at lock0lock.cc:2656:7</span><br><span class="line">   frame #3: 0x000000010c2ee856 mysqld&#96;lock_update_insert(block&#x3D;0x000000012b837a80, rec&#x3D;&quot;\x80&quot;) at lock0lock.cc:3417:3</span><br><span class="line">   frame #4: 0x000000010be41bb2 mysqld&#96;btr_cur_optimistic_insert(flags&#x3D;0, cursor&#x3D;0x00007000070ce478, offsets&#x3D;0x00007000070ce448, heap&#x3D;0x00007000070ce558, entry&#x3D;0x00007fb7587d22c8, rec&#x3D;0x00007000070cdcc8, big_rec&#x3D;0x00007000070cdcc0, n_ext&#x3D;0, thr&#x3D;0x00007fb75797d350, mtr&#x3D;0x00007000070ce8a8) at btr0cur.cc:2928:5</span><br><span class="line">   frame #5: 0x000000010c46f606 mysqld&#96;row_ins_sec_index_entry_low(flags&#x3D;0, mode&#x3D;2, index&#x3D;0x00007fb7587c6c88, offsets_heap&#x3D;0x00007fb75680fc18, heap&#x3D;0x00007fb75681d218, entry&#x3D;0x00007fb7587d22c8, trx_id&#x3D;0, thr&#x3D;0x00007fb75797d350, dup_chk_only&#x3D;false) at row0ins.cc:3004:11</span><br><span class="line">   frame #6: 0x000000010c471fb9 mysqld&#96;row_ins_sec_index_entry(index&#x3D;0x00007fb7587c6c88, entry&#x3D;0x00007fb7587d22c8, thr&#x3D;0x00007fb75797d350, dup_chk_only&#x3D;false) at row0ins.cc:3200:9</span><br><span class="line">   frame #7: 0x000000010c47ce56 mysqld&#96;row_ins_index_entry(index&#x3D;0x00007fb7587c6c88, entry&#x3D;0x00007fb7587d22c8, multi_val_pos&#x3D;0x00007fb75797d130, thr&#x3D;0x00007fb75797d350) at row0ins.cc:3300:13</span><br><span class="line">    省略 ......</span><br></pre></td></tr></table></figure>

<p>这样就成了我们上面看到的结果了。</p>
</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><ul>
<li>这块内容也是看了很多大牛的文章和资料，根据自己对这块知识存在的疑问做了个总结。当然其中还是有很多地方也不是很明白，还需要多看多试验才可以。由于水平有限文章必然也会存在错误，还望大家能够指出问题。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2017/12/02/">http://mysql.taobao.org/monthly/2017/12/02/</a> –MySQL · 引擎特性 · Innodb 锁子系统浅析</li>
<li><a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2016/01/01/">http://mysql.taobao.org/monthly/2016/01/01/</a> –MySQL · 引擎特性 · InnoDB 事务锁系统简介</li>
<li><a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2016/06/01/">http://mysql.taobao.org/monthly/2016/06/01/</a> – MySQL · 特性分析 · innodb 锁分裂继承与迁移</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52098868">https://zhuanlan.zhihu.com/p/52098868</a> –MySQL RC级别下并发insert锁超时问题 - 现象分析和解释</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52100378">https://zhuanlan.zhihu.com/p/52100378</a> –MySQL RC级别下并发insert锁超时问题 - 源码分析</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52234835">https://zhuanlan.zhihu.com/p/52234835</a> –MySQL RC级别下并发insert锁超时问题 - 案例验证</li>
<li><a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2015/06/02/">http://mysql.taobao.org/monthly/2015/06/02/</a> – MySQL · 捉虫动态 · 唯一键约束失效</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1e1e13f8ec27">https://www.jianshu.com/p/1e1e13f8ec27</a> –MySQL：一个死锁分析 (未分析出来的死锁)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" data-id="ckdyc8e4q002drluuc3e0b9or" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%BB%E9%94%81/" rel="tag">死锁</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL复制安全分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/27/MySQL%E5%A4%8D%E5%88%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-02-27T05:56:45.000Z" itemprop="datePublished">2020-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/27/MySQL%E5%A4%8D%E5%88%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/">MySQL复制安全分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL复制安全分析"><a href="#MySQL复制安全分析" class="headerlink" title="MySQL复制安全分析"></a>MySQL复制安全分析</h1><blockquote>
<p>在MySQL复制中我们经常会遇到，Slave异常down机，当Slave再次启动时，会涉及到一个问题，如何能保证复制的正确性(可能是复制报错或者是数据异常)。<br>在5.6包括之前版本没有GTID情况下，需要将IO线程和SQL线程的复制信息都记录到表中并且每一个事物都要将位点信息更新，这样效率比较低，可以设置relay_log_recovey为ON，这样IO线程的位点信息就不用每次都更新了，提高了一定的性能，具体内容可以参考: &lt;<a target="_blank" rel="noopener" href="https://donghy-coredumped.github.io/2018/01/23/MySQL%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/">https://donghy-coredumped.github.io/2018/01/23/MySQL%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</a>&gt; , 此篇文章我们主要分析在GTID情况下的复制安全性</p>
</blockquote>
<h2 id="GTID下的复制安全"><a href="#GTID下的复制安全" class="headerlink" title="GTID下的复制安全"></a>GTID下的复制安全</h2><p>在官方文档中可以看到一个关于复制安全的表格:</p>
<img src="/2020/02/27/MySQL%E5%A4%8D%E5%88%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/1.jpg" class="">
<p>从这个表格中看到，当GTID设置为ON时，并且是MASTER_AUTO_POSITION时，relay_log_recover和relay_log_info_repository设置为任何值对于复制都是安全的。<br>这里就有一些疑问了，如果将relay_log_recover设置为OFF，relay_log_info_repository设置为FILE，Slave意外down机重启后，根据文件中的信息去拉取日志，这时文件中的位点信息有可能不是最新的(因为放在文件中，无法用事务保证位点的信息和应用的事务是原子性的)，这样不就会出现问题嘛？</p>
<h2 id="GTID下Slave向Master拉取日志的方式"><a href="#GTID下Slave向Master拉取日志的方式" class="headerlink" title="GTID下Slave向Master拉取日志的方式"></a>GTID下Slave向Master拉取日志的方式</h2><p>GTID下，Slave向Master拉取日志，和以前基于位点这种方式并不一样，根据官方文档中手册描述，向Master申请拉取的GTID值是根据UNION(@@global.gtid_executed, Retrieved_gtid_set - last_received_GTID)算出来的</p>
<ul>
<li>global.gtid_executed 这个值可以通过Slave上的binlog获取到</li>
<li>Retrieved_gtid_set 和last_received_GTID 都是可以从relay log中获取</li>
</ul>
<p>这样可以看出来GTID模式下，向主库拉取日志的时候需要的值都可以在日志中取到，并不需根据位点信息，所以relay_log_recover和relay_log_info_repository 设置为任何值都是可以的。</p>
<p>详细的内容，可以看下文章最后面的两个链接。</p>
<h2 id="关于还要读取mysql-slave-relay-log-info表的理解"><a href="#关于还要读取mysql-slave-relay-log-info表的理解" class="headerlink" title="关于还要读取mysql.slave_relay_log_info表的理解"></a>关于还要读取mysql.slave_relay_log_info表的理解</h2><p>上面我们知道了GTID的拉取方式，但是在实际环境中，我们发现Slave在异常down机重启后，还是会读取mysql.slave_relay_log_info这个表，这里我个人觉得读取这个表中的内容，就是用于定位要从哪个relay log文件和哪个位点开始扫描，去找Retrieved_gtid_set，并不是利用表里的位点去拉取binlog，因为这个位点信息有可能会是不准的(上面图片中红框的地方显示relay_log_info_repository可以设置为Any)。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0MTczNzA1OA==&amp;mid=2247484693&amp;idx=1&amp;sn=9f54fb01a92a11f478326834aea919fa&amp;chksm=fb242c18cc53a50ef1810f84872c59dc89e7226fa78b7ff66c54f1bae9a3b6e265679241c817&amp;mpshare=1&amp;scene=1&amp;srcid=0808sXwNnl5Bm5hfnUWvRz06&amp;sharer_sharetime=1565273045106&amp;sharer_shareid=696b16f7bf543a042f0c964a25755e34%23rd">https://mp.weixin.qq.com/s?__biz=MzU0MTczNzA1OA==&amp;mid=2247484693&amp;idx=1&amp;sn=9f54fb01a92a11f478326834aea919fa&amp;chksm=fb242c18cc53a50ef1810f84872c59dc89e7226fa78b7ff66c54f1bae9a3b6e265679241c817&amp;mpshare=1&amp;scene=1&amp;srcid=0808sXwNnl5Bm5hfnUWvRz06&amp;sharer_sharetime=1565273045106&amp;sharer_shareid=696b16f7bf543a042f0c964a25755e34%23rd</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0MTczNzA1OA==&amp;mid=2247484696&amp;idx=1&amp;sn=1341c99926c662135d900c1b42f2c800&amp;chksm=fb242c15cc53a50314894a1ada2facbddf8397d8b07c76b9b9601f8eab4ccee73d25d4082e7f&amp;mpshare=1&amp;scene=1&amp;srcid=0808urpY9zSH24QHn9avvZkS&amp;sharer_sharetime=1565273038980&amp;sharer_shareid=696b16f7bf543a042f0c964a25755e34%23rd">https://mp.weixin.qq.com/s?__biz=MzU0MTczNzA1OA==&amp;mid=2247484696&amp;idx=1&amp;sn=1341c99926c662135d900c1b42f2c800&amp;chksm=fb242c15cc53a50314894a1ada2facbddf8397d8b07c76b9b9601f8eab4ccee73d25d4082e7f&amp;mpshare=1&amp;scene=1&amp;srcid=0808urpY9zSH24QHn9avvZkS&amp;sharer_sharetime=1565273038980&amp;sharer_shareid=696b16f7bf543a042f0c964a25755e34%23rd</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/27/MySQL%E5%A4%8D%E5%88%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/" data-id="ckdyc8e3q000irluu49r8b0vs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%8D%E5%88%B6/" rel="tag">复制</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-innodb-large-prefix对查询性能的影响" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/20/innodb-large-prefix%E5%AF%B9%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/" class="article-date">
  <time datetime="2020-02-20T02:10:35.000Z" itemprop="datePublished">2020-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/20/innodb-large-prefix%E5%AF%B9%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/">innodb_large_prefix对查询性能的影响</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="innodb-large-prefix对查询性能的影响"><a href="#innodb-large-prefix对查询性能的影响" class="headerlink" title="innodb_large_prefix对查询性能的影响"></a>innodb_large_prefix对查询性能的影响</h1><blockquote>
<p>前段时间在生产环境遇到个生产问题，开发反应业务系统响应时间很慢，CPU使用率达到百分之百，严重影响到了业务</p>
</blockquote>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>CPU百分之百，首先想到了慢SQL，将慢SQL取出，发现当天慢SQL文件多达60几个(RDS云环境，自己做了分割)，查看文件发现出现大量相同的SQL语句</p>
<img src="/2020/02/20/innodb-large-prefix%E5%AF%B9%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/1.jpg" class="">


<p>这个SQ是用在登录认证， 根据token查询用户信息，按理说这种查询理论上应该效率是非常高的，查看了执行计划如下:</p>
<img src="/2020/02/20/innodb-large-prefix%E5%AF%B9%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/2.jpg" class="">
<p>通过执行计划我们看到了，rows扫描行数还是比较多，跟想象的还是有差距，我们认为应该是根据token唯一定位到某条记录，扫描的行数应该是很少的。<br>查看表结构，发现token这个字段类型是varchar(4000)，默认情况下innodb下创建的索引最大长度是767字节，大概原因我们就知道了，由于字段长度过长，导致创建索引的长度有限，这样实际索引的区分度就非常低了，每次查询都要扫描很多的行，加上这个查询是一个高频的查询，导致了系统运行缓慢。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>这个问题有几种解决方式:</p>
<ul>
<li><p>第一种:<br>修改数据库参数innodb_large_prefix设置为on，这样可以将创建索引的长度扩大到3072，这样可以提高索引数据的区分度，每次查询时扫描的行数就会降低。当天晚上修改了此参数后，查看执行计划rows扫描的行数就降至到了95，并且第二天也无此SQL的慢查询，慢查询日志文件也从前一天的60个文件较少到了1个</p>
</li>
<li><p>第二种:<br>通过增加缓存的方式，将token放到缓存中，减少对数据库的访问次数</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/20/innodb-large-prefix%E5%AF%B9%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/" data-id="ckdyc8e41000vrluu6a4y6ch6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-update-子查询一则优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/25/update-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%88%99%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2019-09-25T01:41:24.000Z" itemprop="datePublished">2019-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/25/update-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%88%99%E4%BC%98%E5%8C%96/">update 子查询一则优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="update-子查询一则优化"><a href="#update-子查询一则优化" class="headerlink" title="update 子查询一则优化"></a>update 子查询一则优化</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>同事找到我，说有个SQL UPDATE 语句，在线上执行了26分钟，都没有执行完成，让我优化下。<br>数据库版本是5.7， 服务器配置4核32G的虚拟机</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>首先就是让同事explain看下执行计划:</p>
<img src="/2019/09/25/update-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%88%99%E4%BC%98%E5%8C%96/1.jpg" class="">

<p>具体的SQL如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> survey_state <span class="keyword">set</span> financ_requirements = <span class="number">1</span> <span class="keyword">where</span> org_credit_code <span class="keyword">in</span> (<span class="keyword">SELECT</span>     org_credit_code   <span class="keyword">FROM</span>    answer_info a     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> answer_detail b       <span class="keyword">ON</span> a.id = b.answer_info_id   <span class="keyword">WHERE</span> b.question_id = <span class="string">&#x27;f32825fa-bd98-11e9-b26c-fa163e4c9a89&#x27;</span>     <span class="keyword">AND</span> b.selection_id = <span class="string">&#x27;0d4ed3a9-bd9b-11e9-b26c-fa163e4c9a89&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个UPDATE带了一个where条件， 里面是一个子查询，执行计划中也可以看到b表是全表扫描，所以首先在b表上创建一个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_question_selection_id <span class="keyword">on</span> answer_detail(question_id, selection_id);</span><br></pre></td></tr></table></figure>
<p>同时也在survey_state表中的org_credit_code字段上创建了个索引:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_org_credit_code <span class="keyword">on</span> survey_state(org_credit_code);</span><br></pre></td></tr></table></figure>

<p>创建索引后让同事再次执行，本以为会很快完成，但是还是需要很长时间。</p>
<h2 id="再次分析执行计划"><a href="#再次分析执行计划" class="headerlink" title="再次分析执行计划"></a>再次分析执行计划</h2><p>再次看执行计划，发现有DEPENDENT SUBQUERY，出现这个代表并不是先执行完子查询(过滤一部分数据)后再与外表做关联，而是外表扫描一条与里面子查询做匹配，然后在做过滤，这样效率自然会低下一些，所以将子查询改成关联查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>   survey_state t1,  (<span class="keyword">SELECT</span>     org_credit_code   <span class="keyword">FROM</span>    answer_info a     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> answer_detail b       <span class="keyword">ON</span> a.id = b.answer_info_id   <span class="keyword">WHERE</span> b.question_id = <span class="string">&#x27;f32825fa-bd98-11e9-b26c-fa163e4c9a89&#x27;</span>     <span class="keyword">AND</span> b.selection_id = <span class="string">&#x27;0d4ed3a9-bd9b-11e9-b26c-fa163e4c9a89&#x27;</span>) t2 <span class="keyword">SET</span>  t1.financ_requirements = <span class="number">1</span> <span class="keyword">WHERE</span> t1.org_credit_code = t2.org_credit_code ;</span><br></pre></td></tr></table></figure>

<p>再次执行，几秒钟完成:</p>
<img src="/2019/09/25/update-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%88%99%E4%BC%98%E5%8C%96/2.jpg" class="">


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/25/update-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%80%E5%88%99%E4%BC%98%E5%8C%96/" data-id="ckdyc8e4l0024rluueso7a027" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL中的松散索引和紧凑索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/15/MySQL%E4%B8%AD%E7%9A%84%E6%9D%BE%E6%95%A3%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A7%E5%87%91%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2019-08-15T06:19:13.000Z" itemprop="datePublished">2019-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/15/MySQL%E4%B8%AD%E7%9A%84%E6%9D%BE%E6%95%A3%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A7%E5%87%91%E7%B4%A2%E5%BC%95/">MySQL中的松散索引和紧凑索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL-Group-By中的松散索引和紧凑索引"><a href="#MySQL-Group-By中的松散索引和紧凑索引" class="headerlink" title="MySQL Group By中的松散索引和紧凑索引"></a>MySQL Group By中的松散索引和紧凑索引</h1><blockquote>
<p>最近看官方文档中发现，有两个索引扫描方式:松散索引和紧凑索引，以前也是看到过，但是一直没有去详细的了解，这次看了下，发现官方文档中说的也不是很清楚，就自己总结下对这两种索引扫描方式的理解</p>
</blockquote>
<h2 id="松散索引-Loose-Index-Scan"><a href="#松散索引-Loose-Index-Scan" class="headerlink" title="松散索引(Loose Index Scan)"></a>松散索引(Loose Index Scan)</h2><p>在官方文档中提到，当有Group By子句时，在特定的情况下可以使用松散索引，减少扫描的次数。官方文档中给出了以下的一些情况可以使用到松散索引:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c1, c2 <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="keyword">SELECT</span> c1, <span class="keyword">MIN</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1;</span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(c3), <span class="keyword">MIN</span>(c3), c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 &gt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c3 = const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br></pre></td></tr></table></figure>
<p>根据官方文档的描述，也就是当语句能满足索引”最左原则”时就可以使用到松散索引。创建个表用于测试:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c3`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c4`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx`</span> (<span class="string">`c1`</span>,<span class="string">`c2`</span>,<span class="string">`c3`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line">表中数据如下:</span><br><span class="line">root@localhost:mysql<span class="number">-8.0</span><span class="number">-3319.</span>sock  <span class="number">10</span>:<span class="number">30</span>:<span class="number">32</span> [dhy]&gt;<span class="keyword">select</span> * <span class="keyword">from</span> t1;</span><br><span class="line">+<span class="comment">------+------+----+------+</span></span><br><span class="line">| c1   | c2   | c3 | c4   |</span><br><span class="line">+<span class="comment">------+------+----+------+</span></span><br><span class="line">|    1 |    2 |  1 |    3 |</span><br><span class="line">|    1 |    2 |  2 |    3 |</span><br><span class="line">|    1 |    2 |  3 |    3 |</span><br><span class="line">+<span class="comment">------+------+----+------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>以”SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2;”这个语句为例，查看其执行计划:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:mysql-8.0-3319.sock  10:32:37 [dhy]&gt;explain SELECT c1, c2 FROM t1 WHERE c3 = 1 GROUP BY c1, c2;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx           | idx  | 14      | NULL |    2 |   100.00 | Using where; Using index for group-by |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>执行计划中Extra这列中出现了 Using index for group-by，代表使用了松散索引，但为何这个语句能用到松散索引，松散索引是到底是什么呢？<br>个人对松散的理解，就像是跳跃索引，”SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2;”这个语句group by c1,c2遵循索引的”最左原则”c1,c2这两列是有序排列的，则可以先对前两列distinct，再过滤c3这个字段，这样减少了前两列的扫描次数。</p>
<h2 id="紧凑索引-Tight-Index-Scan"><a href="#紧凑索引-Tight-Index-Scan" class="headerlink" title="紧凑索引(Tight Index Scan)"></a>紧凑索引(Tight Index Scan)</h2><p>紧凑索引就像是进行了索引全表扫描，以下这两个语句不能使用松散索引，但是可以使用紧凑索引扫描:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 = <span class="string">&#x27;a&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c3;</span><br><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 = <span class="string">&#x27;a&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c2, c3;</span><br></pre></td></tr></table></figure>
<p>先看下执行计划:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:mysql-8.0-3319.sock  11:00:42 [dhy]&gt;explain SELECT c1, c2, c3 FROM t1 WHERE c2 = 2  GROUP BY c1, c3;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | idx           | idx  | 14      | NULL |    3 |    33.33 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>这里type是index，也就是索引全表扫描，并且Extra里没有Using index for group-by，为何这里不能利用松散索引呢？因为group by字段是c1 和 c3两个字段，中间出现了GAP，所以无法按”SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2;”这个SQL一样先distinct c1 ，c2这两个字段，因为c1,c3两个字段组合起来不一定是排序的，只能逐条扫描然后再过滤c2字段的值。例如数据是这样的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">------+------+----+------+</span></span><br><span class="line">| c1   | c2   | c3 | c4   |</span><br><span class="line">+<span class="comment">------+------+----+------+</span></span><br><span class="line">|    1 |    1 |  3 |    3 |</span><br><span class="line">|    1 |    2 |  1 |    3 |</span><br><span class="line">|    1 |    2 |  2 |    3 |</span><br><span class="line">|    1 |    3 |  1 |    3 |</span><br><span class="line">|    2 |    1 |  2 |     3 |</span><br><span class="line">|    2 |    2 |  1 |     3 |</span><br><span class="line">|    2 |    3 |  3 |    3 |</span><br><span class="line">+<span class="comment">------+------+----+------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果按c1和c3两个字段先group by则数据会是这样的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c1 c3 c2</span><br><span class="line">1   3   1</span><br><span class="line">1   1   2</span><br><span class="line">1   2   2</span><br><span class="line">1   1   3</span><br><span class="line">2   2   1</span><br><span class="line">2   1   2</span><br><span class="line">2   3   3</span><br></pre></td></tr></table></figure>
<p>显然c1 和c3 这两列的数据不是排序好的(1,1,2)，(1,2,2)，(1,1,3)，所以如果要做distinct操作则需要进行一次排序操作，或者根据c1这一列开始做索引的全表扫描，这样就保证了数据是有序的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>松散索引其实就是遵循最左原则，这样数据都是有序的，可以不进行排序直接distinct，然后过滤where条件的字段。而紧凑索引数据是无序的，需要进行索引全扫描，会造成多扫描一些数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/15/MySQL%E4%B8%AD%E7%9A%84%E6%9D%BE%E6%95%A3%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A7%E5%87%91%E7%B4%A2%E5%BC%95/" data-id="ckdyc8e3i0009rluub5ocals0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL中组合索引使用小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/MySQL%E4%B8%AD%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/" class="article-date">
  <time datetime="2019-07-25T14:49:16.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/MySQL%E4%B8%AD%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/">MySQL中组合索引使用小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL中组合索引使用小结"><a href="#MySQL中组合索引使用小结" class="headerlink" title="MySQL中组合索引使用小结"></a>MySQL中组合索引使用小结</h1><blockquote>
<p>总结一些MySQL中组合索引，什么情况下会走索引，什么情况下无法走到索引</p>
</blockquote>
<h2 id="测试表结构及数据"><a href="#测试表结构及数据" class="headerlink" title="测试表结构及数据"></a>测试表结构及数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_a_b`</span> (<span class="string">`a`</span>,<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">1</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">下面这两条语句是为了测试场景1中，能出现跳跃索引扫描</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> a, b + <span class="number">5</span> <span class="keyword">FROM</span> t;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">SELECT</span> a, b + <span class="number">10</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<h3 id="场景1where条件后只带有组合索引的第二个字段"><a href="#场景1where条件后只带有组合索引的第二个字段" class="headerlink" title="场景1where条件后只带有组合索引的第二个字段"></a>场景1where条件后只带有组合索引的第二个字段</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:mysql-8.0-3319.sock  16:26:33 [dhy]&gt; explain select a,b from t <span class="built_in">where</span> b = 2;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | range | idx_a_b       | idx_a_b | 10      | NULL |    3 |   100.00 | Using <span class="built_in">where</span>; Using index <span class="keyword">for</span> skip scan |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+----------------------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>从执行计划中可以看到，key这列显示使用到索引，同时key_ley的长度是10，也就是使用到了组合索引的所有字段，Extra中显示走了跳跃索引扫描(Using index for skip scan)，如果是8.0以下的版本则不会出现跳跃索引，而是索引全表扫描。<br>这里执行时的流程应该是如下发生:</p>
<ul>
<li><p>获取组合索引中，第一列去重之后的第一个值(本例子中就是a=1)</p>
</li>
<li><p>根据此值与组合索引中的第二列构成一个查询条件(a=1 and b = 2)</p>
</li>
<li><p>执行查询</p>
</li>
<li><p>获取组合索引中，第一列去重之后的第二个值(本例子中就是a=2)</p>
</li>
<li><p>根据此值与组合索引中的第二列构成一个查询条件(a=2 and b = 2)</p>
</li>
<li><p>执行查询</p>
</li>
</ul>
<p>反复按以上规则执行，直到第一列去重之后的值全部扫描完成</p>
<h3 id="场景2where条件后第一列是范围查询"><a href="#场景2where条件后第一列是范围查询" class="headerlink" title="场景2where条件后第一列是范围查询"></a>场景2where条件后第一列是范围查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t <span class="built_in">where</span> a &gt; 1 and b = 2;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | range | idx_a_b       | idx_a_b | 5       | NULL |    6 |    11.11 | Using <span class="built_in">where</span>; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从这个执行计划中看到，key_len是5，也就是只使用到了组合索引的一部分，其实这里只使用到了组合索引的前半部分。<br>为何只能使用前半部分呢？我们再看下表中数据情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t ;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |    1 |</span><br><span class="line">|    1 |    2 |</span><br><span class="line">|    1 |    3 |</span><br><span class="line">|    2 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    2 |    3 |</span><br><span class="line">|    3 |    1 |</span><br><span class="line">|    3 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">9 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>当a&gt;1这个where条件过滤后，数据就变成了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t <span class="built_in">where</span> a &gt; 1 ;</span><br><span class="line">+------+------+</span><br><span class="line">| a    | b    |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 |    1 |</span><br><span class="line">|    2 |    2 |</span><br><span class="line">|    2 |    3 |</span><br><span class="line">|    3 |    1 |</span><br><span class="line">|    3 |    2 |</span><br><span class="line">|    3 |    3 |</span><br><span class="line">+------+------+</span><br><span class="line">6 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>这里a字段是排序的，但是b字段则是无序的，所以第二列是无法用到索引的。</p>
<p>同理我们就知道了，只要第一列是范围查询，后面的第二列则无法用到索引，向下面这种order by和group by也是同样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t <span class="built_in">where</span> a &gt; 1 order by b ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | <span class="built_in">type</span>  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | range | idx_a_b       | idx_a_b | 5       | NULL |    6 |   100.00 | Using <span class="built_in">where</span>; Using index; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到这里使用到了排序，在MySQL8.0中explain 后面加上format=tree可以更加清楚看到执行顺序:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oot@localhost:mysql-8.0-3319.sock  22:07:57 [dhy]&gt;explain format=tree select * from t <span class="built_in">where</span> a &gt; 1 order by b ;</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| EXPLAIN                                                                               |</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| -&gt; Sort: t.b</span><br><span class="line">    -&gt; Filter: (t.a &gt; 1)</span><br><span class="line">        -&gt; Index range scan on t using idx_a_b</span><br><span class="line"> |</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>先根据索引做范围查询，过滤掉不满足条件(a&gt;1)的数据，然后在根据b字段排序</p>
<h3 id="场景3where条件后第一列是等值查询"><a href="#场景3where条件后第一列是等值查询" class="headerlink" title="场景3where条件后第一列是等值查询"></a>场景3where条件后第一列是等值查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t <span class="built_in">where</span> a =1 and b = 2 ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | <span class="built_in">type</span> | possible_keys | key     | key_len | ref         | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ref  | idx_a_b       | idx_a_b | 10      | const,const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+---------+---------+-------------+------+----------+-------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>这个执行计划就非常好了，用到了索引，并且key_len是10，同时select_type是ref代表是索引扫描(不是全扫描)。<br>之所以这里能使用组合索引两个字段做索引扫描的原因，是因为根据第一例的值查询后，第二列的值也是排序的，所以能利用到第二列的索引</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/MySQL%E4%B8%AD%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/" data-id="ckdyc8e3m000drluu35b2h0rz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL%E4%BC%98%E5%8C%96/" rel="tag">SQL优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL-Group-Replication中同步的几个过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2019-06-23T04:28:32.000Z" itemprop="datePublished">2019-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/">MySQL Group Replication中同步的几个过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Group-Replication中同步的几个过程"><a href="#Group-Replication中同步的几个过程" class="headerlink" title="Group Replication中同步的几个过程"></a>Group Replication中同步的几个过程</h1><blockquote>
<p>MGR组复制大家都知道是一个数据强一致性的架构，但是这个强一致性是最终一致性，也就是在正常的复制过程中各个节点之间还是存在延迟，这篇文章目的是梳理下MGR的几个同步过程。</p>
</blockquote>
<h2 id="Group-Replication数据同步的几个阶段"><a href="#Group-Replication数据同步的几个阶段" class="headerlink" title="Group Replication数据同步的几个阶段"></a>Group Replication数据同步的几个阶段</h2><p>MGR中数据同步可以分为以下几个阶段:</p>
<ul>
<li>locally applying</li>
<li>generating a binlog event</li>
<li>sending the binlog event to the slave(s)</li>
<li>adding the binlog event on the relay log</li>
<li>applying the binlog event from the relay log</li>
</ul>
<p>这几个阶段中只有sending the binlog event to the slave这个过程是一个同步过程(要等待包过自己在内的大部分节点返回ACK)，这个过程包含了数据冲突检测。</p>
<h3 id="locally-applying"><a href="#locally-applying" class="headerlink" title="locally applying"></a>locally applying</h3><p>这个阶段也就是本地事务执行，具体步骤如下:</p>
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx1.png" class="">
<p>首先开启事务</p>
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx2.png" class="">
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx3.png" class="">
<p>在事务内执行一些语句</p>
<h3 id="generating-a-binlog-event"><a href="#generating-a-binlog-event" class="headerlink" title="generating a binlog event"></a>generating a binlog event</h3><p>这个阶段主要是生产binlog event ，用于MGR将他封装成write set 通过paxos原子广播到各个节点</p>
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx4.png" class="">
<p>当事务提交时会产生 binlog event</p>
<h3 id="sending-the-binlog-event-to-the-slave-s"><a href="#sending-the-binlog-event-to-the-slave-s" class="headerlink" title="sending the binlog event to the slave(s)"></a>sending the binlog event to the slave(s)</h3><p>发送binlog event到各个节点(其实也就是write set)，但这个步骤是一个同步的过程, 这里就用了paxos协议将数据有序的广播出去，需要有包括自己在内的大多数节点返回ack之后才会继续</p>
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx5-1.png" class="">
<p>每个节点收到发送到的binlog event 就要在自己的本地做冲突检测</p>
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx6-1.png" class="">

<h3 id="adding-the-binlog-event-on-the-relay-log-applying-the-binlog-event-from-the-relay-log"><a href="#adding-the-binlog-event-on-the-relay-log-applying-the-binlog-event-from-the-relay-log" class="headerlink" title="adding the binlog event on the relay log/applying the binlog event from the relay log"></a>adding the binlog event on the relay log/applying the binlog event from the relay log</h3><p>当node1节点，完成冲突检测后，node1节点上的事务commit就可以继续执行了</p>
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx7-1.png" class="">
<p>从上面这个图可以看出，node1上面可以继续commit了，不用等待别的节点完成冲突检测，或者是应用完事务</p>
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx8-1.png" class="">
<img src="/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/cert_trx9-3.png" class="">
<p>别的节异步的应用队列中的数据，并且可以看到数据在不同的节点上提交的时间也是不一样的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的步骤图我们了解了MGR同步的几个阶段，知道了MGR的数据强一致性并不是需要等到每个节点都应用完事务，而是只在发送binlog<br>event做冲突校验这个阶段是同步的过程，其余阶段都是异步的，也就是各个节点读取到的数据可能存在延迟，所以在MySQL8.0.14中增加了group_replication_consistency参数，用于一致性读</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><p><a target="_blank" rel="noopener" href="https://lefred.be/content/mysql-group-replication-synchronous-or-asynchronous-replication/">https://lefred.be/content/mysql-group-replication-synchronous-or-asynchronous-replication/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/23/MySQL-Group-Replication%E4%B8%AD%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E4%B8%AA%E8%BF%87%E7%A8%8B/" data-id="ckdyc8e3b0003rluu26rtb89c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MGR/" rel="tag">MGR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL-Group-Replicaton/" rel="tag">MySQL Group Replicaton</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Greenplum/" rel="tag">Greenplum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Innodb/" rel="tag">Innodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Innodb-Lock/" rel="tag">Innodb Lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MGR/" rel="tag">MGR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVCC/" rel="tag">MVCC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL-Group-Replicaton/" rel="tag">MySQL Group Replicaton</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PosgreSQL-%E6%BA%90%E7%A0%81/" rel="tag">PosgreSQL 源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/" rel="tag">PostgreSQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E4%BC%98%E5%8C%96/" rel="tag">SQL优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WAL%E6%97%A5%E5%BF%97/" rel="tag">WAL日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E4%BB%8E/" rel="tag">主从</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E5%8C%96/" rel="tag">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/" rel="tag">备份恢复</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%8D%E5%88%B6/" rel="tag">复制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" rel="tag">查询优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%BB%E9%94%81/" rel="tag">死锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF/" rel="tag">统计信息</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Greenplum/" style="font-size: 10px;">Greenplum</a> <a href="/tags/Innodb/" style="font-size: 10px;">Innodb</a> <a href="/tags/Innodb-Lock/" style="font-size: 10px;">Innodb Lock</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MGR/" style="font-size: 12px;">MGR</a> <a href="/tags/MVCC/" style="font-size: 10px;">MVCC</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/MySQL-Group-Replicaton/" style="font-size: 12px;">MySQL Group Replicaton</a> <a href="/tags/PosgreSQL-%E6%BA%90%E7%A0%81/" style="font-size: 10px;">PosgreSQL 源码</a> <a href="/tags/PostgreSQL/" style="font-size: 18px;">PostgreSQL</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 12px;">SQL优化</a> <a href="/tags/WAL%E6%97%A5%E5%BF%97/" style="font-size: 10px;">WAL日志</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/%E4%B8%BB%E4%BB%8E/" style="font-size: 10px;">主从</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 16px;">优化</a> <a href="/tags/%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/" style="font-size: 10px;">备份恢复</a> <a href="/tags/%E5%A4%8D%E5%88%B6/" style="font-size: 12px;">复制</a> <a href="/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" style="font-size: 10px;">查询优化</a> <a href="/tags/%E6%AD%BB%E9%94%81/" style="font-size: 14px;">死锁</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF/" style="font-size: 12px;">统计信息</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/17/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/08/17/Innodb%E7%B3%BB%E7%BB%9F%E8%A1%A8-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/">Innodb系统表-结构解析</a>
          </li>
        
          <li>
            <a href="/2020/06/08/MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6SQL%E5%9C%A8%E6%B5%8B%E8%AF%95-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84/">MySQL中如何控制SQL在测试-生产环境具有相同的执行路径</a>
          </li>
        
          <li>
            <a href="/2020/04/04/RC%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E6%AD%BB%E9%94%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/">RC隔离级别下，死锁案例分析</a>
          </li>
        
          <li>
            <a href="/2020/02/27/MySQL%E5%A4%8D%E5%88%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/">MySQL复制安全分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Dong Hong Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>